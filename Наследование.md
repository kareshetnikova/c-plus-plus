## Наследование


Можно без всяких приписок использовать методы из класса-родителя.    
Наследуются поля и методы.

***Пример:***
```
class Animal {
public:
    virtual string getType() = 0;
};

class Monkey : public Animal {
public:
    string getType() override { return "Monkey"; }
};
```




### Виртуальные методы

Класс с виртуальными методами - абстрактные. Нельзя создавать объекты
абстрактных классов. В наследниках можно использовать методы 
родителей-абстрактных классов.   

`virtual void f() = 0;` значит вот что:   
Приравнивание виртуальной функции к нулю - синтаксис, обозначающий чисто
виртуальную функцию. То есть функцию, которая ничего не выполняет, а создана
только для переопределения во всех производных классах от класса, в котором 
имеется такая функция. Чистая виртуальная функция должна быть обязательно 
переопределена в каждом производном классе.      

Интерфейсный класс - все методы абстрактные.   


***Пример:***
```
class Base
{
public:
    virtual void f() = 0;
};

class Derived : public Base
{
public:
    void f();
};
```

***override***   

Ключевое слово override используется для явного указания того, что метод переопределяет виртуальный метод базового класса. Вроде как в codi::blocks работает только с 
чисто виртуальными методами. Для обычных он и не нужен.      

*см. самый первый код в качестве примера*     

***Приколы с деструктором и динамической памятью***    

Если в классе выделяется динамическая память и он является родителем другого класса, то в унаследованном классе деструктор, 
освобождающий место, не будет вызван. Из-за этого могут быть проблемы с памятью. Чтоб решить эту проблему, надо сделать 
деструктор в классе-родителе виртуальным: `virtual ~Storage()`.

### Множественное наследование     
***Пример***    
```
class SmartCat: public NPC, public Animal
{
public:
    void pet()
    {
      cout << "Meow!" << endl;
    }

    void talk()
    {
        cout << "Meow!" << endl;
    }

};
```
